# 概念

## GMP调度模型

[//]: # (![GMP模型]&#40;./images/gmp_mode.png&#41;)

<img src="./images/gmp_mode.png" alt="GMP调度模型" height="400">


### 三个资源的缩写

- Goroutine  
go 关键字执行的函数，要执行的业务代码，统称为 goroutine

- Machine  
内核的物理线程，Go语言在此基础上进行了封装  
正常M的数量要大于P的数量

- Processor  
逻辑处理器 或者 goroutine的调度器，负责调度G的执行；  
正常P的数量等于CPU的数量


### 执行G的过程

P是负责调度G的，创建G时会先把G放入P的一个本地队列中，M要和P建立绑定关系，P调度本地队列中的G到M进行执行。

如果P上的队列中的G被执行完了，那么P会从全局队列中拿G，但是如果从全局队列中拿G就要加锁，势必会影响一定的性能。

从全局队列中拿G是为了防止部分G饿死。

### work stealing 工作窃取

如果P上队列中的G被执行完了，那么P可以通过窃取的方式，从其其它P上拿取一半的G放入到自已的本地队列中，
在继续调度执行G

### 系统调用 引起阻塞

如果M在绑定P后，执行P上的G时，发生了系统调用，这时要阻塞，为了使P上的其它的G继续执行，这个时候P就要和M解绑，
让此时M1和G1单独绑定；让P去寻找其它的M，如果有其他休眠的M，唤醒使其和P绑定，继续执行其它的G；一段时间后，原来
阻塞的M1和G1系统调用完成，这个时候如果有空闲的P则进行绑定继续执行G1，反之则把G1放入到全局队列中。



## 垃圾回收




